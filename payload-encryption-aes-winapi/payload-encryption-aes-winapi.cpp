#include "misc.h"
#include <bcrypt.h>

#pragma comment(lib, "Bcrypt.lib")

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

// for AES CBC mode:
#define KEYSIZE 32
#define IVSIZE 16


typedef struct _AES {

	PBYTE pPlainText;         // base address of the plain text data 
	DWORD dwPlainSize;        // size of the plain text data

	PBYTE pCipherText;        // base address of the encrypted data	
	DWORD dwCipherSize;       // size of it (this can change from dwPlainSize in case there was padding)

	PBYTE pKey;               // the 32 byte key
	PBYTE pIv;                // the 16 byte iv

} AES, *PAES;

BOOL AesEncryptionCNG(PAES pAes)
{	
	NTSTATUS status = NULL;

	BOOL bSTATE = TRUE;
	BCRYPT_ALG_HANDLE hAlgorithm = NULL;
	BCRYPT_KEY_HANDLE hKeyHandle = NULL;

	ULONG cbResult = NULL;
	DWORD dwBlockSize = NULL;

	DWORD cbKeyObject = NULL;
	PBYTE pbKeyObject = NULL;

	PBYTE pbCipherText = NULL;
	DWORD cbCipherText = NULL;


	// Intializing "hAlgorithm" as AES algorithm Handle
	status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptOpenAlgorithmProvider", status);
		bSTATE = FALSE;
	}

	// Getting the size of the key object variable pbKeyObject. This is used by the BCryptGenerateSymmetricKey function later 
	status = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbResult, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptGetProperty (first call)", status);
		bSTATE = FALSE;
	}

	// Getting the size of the block used in the encryption. Since this is AES it must be 16 bytes.
	status = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&dwBlockSize, sizeof(DWORD), &cbResult, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptGetProperty (second call)", status);
		bSTATE = FALSE;
	}

	// Checking if block size is 16 bytes
	if (dwBlockSize != 16)
	{
		bSTATE = FALSE;
	}

	// Allocating memory for the key object 
	pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
	if (pbKeyObject == NULL)
	{
		printError(L"HeapAlloc");
		bSTATE = FALSE;
	}

	// Setting Block Cipher Mode to CBC. This uses a 32 byte key and a 16 byte IV.
	status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptSetProperty", status);
		bSTATE = FALSE;
	}

	// Generating the key object from the AES key "pAes->pKey". The output will be saved in pbKeyObject and will be of size cbKeyObject 
	status = BCryptGenerateSymmetricKey(hAlgorithm, &hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes->pKey, KEYSIZE, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptGenerateSymmetricKey", status);
		bSTATE = FALSE;
	}

	// Running BCryptEncrypt first time with NULL output parameters to retrieve the size of the output buffer which is saved in cbCipherText
	status = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes->pPlainText, (ULONG)pAes->dwPlainSize, NULL, pAes->pIv, IVSIZE, NULL, 0, &cbCipherText, BCRYPT_BLOCK_PADDING);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptEncrypt (first call)", status);
		bSTATE = FALSE;
	}

	// Allocating enough memory for the output buffer, cbCipherText
	pbCipherText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbCipherText);
	if (pbCipherText == NULL)
	{
		printError(L"HeapAlloc");
		bSTATE = FALSE;
	}

	// Running BCryptEncrypt again with pbCipherText as the output buffer
	status = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes->pPlainText, (ULONG)pAes->dwPlainSize, NULL, pAes->pIv, IVSIZE, pbCipherText, cbCipherText, &cbResult, BCRYPT_BLOCK_PADDING);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptEncrypt (second call)", status);
		bSTATE = FALSE;
	}

	if (hKeyHandle)
	{
		BCryptDestroyKey(hKeyHandle);
	}

	if (hAlgorithm)
	{
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
	}

	if (pbKeyObject)
	{
		HeapFree(GetProcessHeap(), 0, pbKeyObject);
	}

	if (pbCipherText != NULL && bSTATE)
	{
		pAes->pCipherText = pbCipherText;
		pAes->dwCipherSize = cbCipherText;
	}

	return bSTATE;
}

BOOL AesDecryptionCNG(PAES pAes)
{
	NTSTATUS status = NULL;

	BOOL bSTATE = TRUE;
	BCRYPT_ALG_HANDLE hAlgorithm = NULL;
	BCRYPT_KEY_HANDLE hKeyHandle = NULL;

	ULONG cbResult = NULL;
	DWORD dwBlockSize = NULL;

	DWORD cbKeyObject = NULL;
	PBYTE pbKeyObject = NULL;

	PBYTE pbPlainText = NULL;
	DWORD cbPlainText = NULL;

	status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptOpenAlgorithmProvider", status);
		bSTATE = FALSE;
	}

	status = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&cbKeyObject, sizeof(DWORD), &cbResult, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptGetProperty (first call)", status);
		bSTATE = FALSE;
	}

	status = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&dwBlockSize, sizeof(DWORD), &cbResult, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptGetProperty (second call)", status);
		bSTATE = FALSE;
	}

	if (dwBlockSize != 16)
	{
		bSTATE = FALSE;
	}

	pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
	if (pbKeyObject == NULL)
	{
		printError(L"HeapAlloc");
		bSTATE = FALSE;
	}

	status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptSetProperty", status);
		bSTATE = FALSE;
	}

	status = BCryptGenerateSymmetricKey(hAlgorithm, &hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes->pKey, KEYSIZE, 0);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptGenerateSymmetricKey", status);
		bSTATE = FALSE;
	}

	status = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes->pCipherText, (ULONG)pAes->dwCipherSize, NULL, pAes->pIv, IVSIZE, NULL, 0, &cbPlainText, BCRYPT_BLOCK_PADDING);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptDecrypt (first call)", status);
		bSTATE = FALSE;
	}

	pbPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbPlainText);
	if (pbPlainText == NULL)
	{
		printError(L"HeapAlloc");
		bSTATE = FALSE;
	}

	status = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes->pCipherText, (ULONG)pAes->dwCipherSize, NULL, pAes->pIv, IVSIZE, pbPlainText, cbPlainText, &cbResult, BCRYPT_BLOCK_PADDING);
	if (!NT_SUCCESS(status))
	{
		printNtStatus(L"BCryptDecrypt (second call)", status);
		bSTATE = FALSE;
	}

	if (hKeyHandle)
	{
		BCryptDestroyKey(hKeyHandle);
	}

	if (hAlgorithm)
	{
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
	}

	if (pbKeyObject)
	{
		HeapFree(GetProcessHeap(), 0, pbKeyObject);
	}

	if (pbPlainText != NULL && bSTATE)
	{
		pAes->pPlainText = pbPlainText;
		pAes->dwPlainSize = cbPlainText;
	}
	return bSTATE;
}


BOOL SimpleEncryption(IN PVOID pPlainTextData, IN DWORD sPlainTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pCipherTextData, OUT DWORD* sCipherTextSize)
{
	if (pPlainTextData == NULL || sPlainTextSize == NULL || pKey == NULL || pIv == NULL)
		return FALSE;

	// Intializing the struct
	AES Aes = { 0 };
	Aes.pKey = pKey;
	Aes.pIv = pIv;
	Aes.pPlainText = (PBYTE)pPlainTextData;
	Aes.dwPlainSize = sPlainTextSize;

	if (!AesEncryptionCNG(&Aes)) {
		return FALSE;
	}

	// Saving output
	*pCipherTextData = Aes.pCipherText;
	*sCipherTextSize = Aes.dwCipherSize;

	return TRUE;
}

BOOL SimpleDecryption(IN PVOID pCipherTextData, IN DWORD sCipherTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pPlainTextData, OUT DWORD* sPlainTextSize)
{
	if (pCipherTextData == NULL || sCipherTextSize == NULL || pKey == NULL || pIv == NULL)
		return FALSE;

	// Intializing the struct
	AES Aes = { 0 };
	Aes.pKey = pKey;
	Aes.pIv = pIv;
	Aes.pCipherText = (PBYTE)pCipherTextData;
	Aes.dwCipherSize = sCipherTextSize;

	if (!AesDecryptionCNG(&Aes)) {
		return FALSE;
	}

	// Saving output
	*pPlainTextData = Aes.pPlainText;
	*sPlainTextSize = Aes.dwPlainSize;

	return TRUE;
}


int main()
{
	// msfvenom -p windows/exec CMD=notepad.exe -f c
	BYTE bufClear[] =
		"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50"
		"\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26"
		"\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
		"\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78"
		"\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3"
		"\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
		"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58"
		"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3"
		"\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"
		"\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d"
		"\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb"
		"\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c"
		"\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53"
		"\xff\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";

	DWORD sBufClear = (sizeof(bufClear) / sizeof(BYTE)) - 1;

	BYTE pKey[] =
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

	DWORD sKey = (sizeof(pKey) / sizeof(BYTE)) - 1;

	BYTE pIv[] =
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

	DWORD sIv = (sizeof(pIv) / sizeof(BYTE)) - 1;

	printHex(bufClear, sBufClear);
	printHex(pKey, sKey);
	printHex(pIv, sIv);

	PVOID pCipherText = NULL;
	DWORD dwCipherSize = NULL;

	SimpleEncryption(bufClear, sBufClear, pKey, pIv, &pCipherText, &dwCipherSize);

	printHex((PBYTE)pCipherText, dwCipherSize);

	PVOID pClearText = NULL;
	DWORD dwClearSize = NULL;

	BYTE pKeyD[] =
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

	BYTE pIvD[] =
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

	SimpleDecryption(pCipherText, dwCipherSize, pKeyD, pIvD, &pClearText, &dwClearSize);

	printHex((PBYTE)pClearText, dwClearSize);

	return 0;
}