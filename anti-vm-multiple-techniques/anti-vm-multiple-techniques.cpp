#include <Windows.h>
#include <Shlwapi.h>
#include <cstdint>
#include <psapi.h>
#include <intrin.h>
#include "misc.h"


BOOL chk_TooLittleCPUs()
{
	BOOL bRet = FALSE;

	SYSTEM_INFO   SysInfo = { 0 };
	
	wprintf(L"[*] TooLittleCPUs: ");

	GetSystemInfo(&SysInfo);
	if (SysInfo.dwNumberOfProcessors < 2)
	{
		bRet = TRUE;
	}

	wprintf(L"(%d) %s\n", SysInfo.dwNumberOfProcessors, (bRet) ? L"yes" : L"no");
	return bRet;
}

BOOL chk_TooLittleRAM()
{
	BOOL bRet = FALSE;

	MEMORYSTATUSEX stMemStatus = { 0 };
	stMemStatus.dwLength = sizeof(MEMORYSTATUSEX);

	wprintf(L"[*] TooLittleRAM: ");

	if (!GlobalMemoryStatusEx(&stMemStatus))
	{
		printError(L"GlobalMemoryStatusEx");
	}

	if ((DWORD)stMemStatus.ullTotalPhys <= (DWORD)(2 * 1073741824))
	{
		bRet = TRUE;
	}

	wprintf(L"(%llu) %s\n", stMemStatus.ullTotalPhys, (bRet) ? L"yes" : L"no");
	return bRet;
}

BOOL chk_TooLittleMountedUSBs()
{
	BOOL bRet = FALSE;
	
	HKEY hKey = NULL;
	LSTATUS lStatus = 0;
	DWORD dwCount = 0;

	wprintf(L"[*] TooLittleMountedUSBs: ");

	lStatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Enum\\USB", NULL, KEY_READ, &hKey);
	if (lStatus != ERROR_SUCCESS)
	{
		printError(L"RegOpenKeyExA", lStatus);
	}
	
	lStatus = RegQueryInfoKeyA(hKey, NULL, NULL, NULL, &dwCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	if (lStatus != ERROR_SUCCESS)
	{
		printError(L"RegOpenKeyExA", lStatus);
	}

	if (dwCount < 5)
	{
		bRet = TRUE;
	}

	wprintf(L"(%lu) %s\n", dwCount, (bRet) ? L"yes" : L"no");
	return bRet;
}


BOOL CALLBACK screenResCallback(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARAM ldata)
{
	INT x = 0, y = 0;
	MONITORINFO stMonitorInfo = { 0 };
	stMonitorInfo.cbSize = sizeof(MONITORINFO);

	if (!GetMonitorInfoW(hMonitor, &stMonitorInfo))
	{
		printError(L"GetMonitorInfoW");
		return FALSE;
	}

	x = abs(stMonitorInfo.rcMonitor.right - stMonitorInfo.rcMonitor.left);
	y = abs(stMonitorInfo.rcMonitor.top - stMonitorInfo.rcMonitor.bottom);

	wprintf(L"\t%d x %d: ", x, y);

	if ((x != 1920 && x != 2560 && x != 1440) || (y != 1080 && y != 1200 && y != 1600 && y != 900))
	{
		wprintf(L"yes\n");
		*((BOOL*)ldata) = TRUE;
	}
	else
	{
		wprintf(L"no\n");
	}

	return TRUE;
}

BOOL chk_IsScreenResNonStandard()
{
	BOOL bRet = FALSE;

	wprintf(L"[*] IsScreenResNonStandard: \n");
	
	if (!EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)screenResCallback, (LPARAM)(&bRet)))
	{
		printError(L"EnumDisplayMonitors");
	}
	
	//wprintf(L"%s\n", (bRet) ? L"yes" : L"no");

	return bRet;
}

BOOL chk_NumberOfDigitsInFilename()
{
	BOOL bRet = FALSE;
	DWORD dwRet = 0;

	WCHAR	szPath[MAX_PATH] = { 0 };
	WCHAR	szFilename[MAX_PATH] = { 0 };
	DWORD   dwNumberOfDigits = 0;

	wprintf(L"[*] NumberOfDigitsInFilename: ");

	dwRet = GetModuleFileNameW(NULL, szPath, MAX_PATH);
	if(dwRet == 0)
	{
		printError(L"GetModuleFileNameW");
	}

	lstrcpyW(szFilename, PathFindFileNameW(szPath));

	for (int i = 0; i < lstrlenW(szFilename); i++)
	{
		if (isdigit(szFilename[i]))
		{
			dwNumberOfDigits++;
		}
	}

	if (dwNumberOfDigits > 3)
	{
		bRet = TRUE;
	}

	wprintf(L"(%d) %s\n", dwNumberOfDigits, (bRet) ? L"yes" : L"no");

	return bRet;
}

BOOL chk_NumberOfRunningProcesses()
{
	BOOL bRet = FALSE;
	DWORD dwRet = 0;

	DWORD lpidProcess[4096] = { 0 };
	DWORD cProcesses = 0;
	DWORD cbNeeded = 0;;

	wprintf(L"[*] NumberOfRunningProcesses: ");

	dwRet = EnumProcesses(lpidProcess, sizeof(lpidProcess), &cbNeeded);
	if (!dwRet)
	{
		printError(L"EnumProcesses");
	}

	cProcesses = cbNeeded / sizeof(DWORD);
	
	if (cProcesses < 50)
	{
		bRet = TRUE;
	}

	wprintf(L"(%d) %s\n", cProcesses, (bRet) ? L"yes" : L"no");

	return bRet;
}

HHOOK g_hMouseHook = NULL;
DWORD g_dwMouseClicks = 0;

LRESULT CALLBACK hookMouseEvent(int nCode, WPARAM wParam, LPARAM lParam)
{
	if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN) {
		g_dwMouseClicks++;
	}

	return CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);
}

void mouseClicksLogger()
{
	MSG msg = { 0 };

	g_hMouseHook = SetWindowsHookExW(WH_MOUSE_LL, (HOOKPROC)hookMouseEvent, NULL, NULL);

	if (!g_hMouseHook)
	{
		printError(L"SetWindowsHookExW");
	}

	while (GetMessageW(&msg, NULL, NULL, NULL))
	{
		DefWindowProcW(msg.hwnd, msg.message, msg.wParam, msg.lParam);
	}
}

BOOL chk_NumberOfMouseClicks()
{
	BOOL bRet = FALSE;

	HANDLE hThread = NULL;
	DWORD dwThreadId = NULL;

	wprintf(L"[*] NumberOfMouseClicks: ");

	hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)mouseClicksLogger, NULL, NULL, &dwThreadId);
	if (!hThread)
	{
		printError(L"CreateThread");
	}

	WaitForSingleObject(hThread, 20000);

	if (g_hMouseHook && !UnhookWindowsHookEx(g_hMouseHook))
	{
		printError(L"UnhookWindowsHookEx");
	}

	if (g_dwMouseClicks < 5)
	{
		bRet = TRUE;
	}

	wprintf(L"(%d) %s\n", g_dwMouseClicks, (bRet) ? L"yes" : L"no");

	return bRet;
}

// https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html

UINT64 UmpIsSystemVirtualized(void)
{
	BOOL bRet = FALSE;

	unsigned int invalid_leaf = 0x13371337;
	unsigned int valid_leaf = 0x40000000;

	struct _HV_DETAILS
	{
		unsigned int Data[4];
	};

	_HV_DETAILS InvalidLeafResponse = { 0 };
	_HV_DETAILS ValidLeafResponse = { 0 };

	wprintf(L"[*] UmpIsSystemVirtualized: ");

	__cpuid((int*)& InvalidLeafResponse, invalid_leaf);
	__cpuid((int*)&ValidLeafResponse, valid_leaf);

	if ((InvalidLeafResponse.Data[0] != ValidLeafResponse.Data[0]) ||
		(InvalidLeafResponse.Data[1] != ValidLeafResponse.Data[1]) ||
		(InvalidLeafResponse.Data[2] != ValidLeafResponse.Data[2]) ||
		(InvalidLeafResponse.Data[3] != ValidLeafResponse.Data[3]))
	{ 
		bRet = TRUE;
	}

	wprintf(L"%s\n", (bRet) ? L"yes" : L"no");

	return bRet;
}

BOOL UmpIsSystemVirtualized2()
{
	BOOL bRet = FALSE;

	typedef struct _cpuid_buffer_t {
		INT32 eax;
		INT32 ebx;
		INT32 ecx;
		INT32 edx;
	}cpuid_buffer_t;

	wprintf(L"[*] UmpIsSystemVirtualized2: ");

	cpuid_buffer_t regs;
	__cpuid((int32_t*)&regs, 0x40000000);

	cpuid_buffer_t reserved_regs;
	__cpuid((int32_t*)&reserved_regs, 0);
	__cpuid((int32_t*)&reserved_regs, reserved_regs.eax);

	if (reserved_regs.eax != regs.eax ||
		reserved_regs.ebx != regs.ebx ||
		reserved_regs.ecx != regs.ecx ||
		reserved_regs.edx != regs.edx)
	{
		bRet = TRUE;
	}

	wprintf(L"%s\n", (bRet) ? L"yes" : L"no");

	return bRet;
}

int main()
{
	chk_TooLittleCPUs();
	chk_TooLittleRAM();
	chk_TooLittleMountedUSBs();
	chk_IsScreenResNonStandard();
	chk_NumberOfDigitsInFilename();
	chk_NumberOfRunningProcesses();
	chk_NumberOfMouseClicks();
	UmpIsSystemVirtualized();
	UmpIsSystemVirtualized2();

	return 0;
}