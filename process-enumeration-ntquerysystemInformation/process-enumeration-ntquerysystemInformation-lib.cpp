#include <Windows.h>
#include <winternl.h>
#include "misc.h"
#include "process-enumeration-ntquerysystemInformation-lib.h"

typedef NTSTATUS(NTAPI* fnNtQuerySystemInformation)
(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID                    SystemInformation,
	ULONG                    SystemInformationLength,
	PULONG                   ReturnLength
);


BOOL GetRemoteProcessHandleNtQuerySystemInformation(IN LPCWSTR szProcName, OUT DWORD* pdwPid, OUT HANDLE* phProcess, IN OUT DWORD* dwProcesses)
{
	fnNtQuerySystemInformation pNtQuerySystemInformation = NULL;

	NTSTATUS lStatus = NULL;
	ULONG ulProcesses = 0;

	PSYSTEM_PROCESS_INFORMATION systemProcInfoOrig = NULL;
	PSYSTEM_PROCESS_INFORMATION systemProcInfo = NULL;

	DWORD dwOutSize = 0;


	wprintf(L"[>] Looking for process: START\n");
	wprintf(L"[i] Process name: \"%s\"\n", szProcName);
	do
	{
		wprintf(L"\t[i] Getting address of NtQuerySystemInformation... ");
		pNtQuerySystemInformation = (fnNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"NTDLL.DLL"), "NtQuerySystemInformation");
		if (pNtQuerySystemInformation == NULL)
		{
			printError(L"GetProcAddress");
			break;
		}
		wprintf(L"done, address: 0x%p\n", pNtQuerySystemInformation);

		wprintf(L"\t[i] Getting size of data to be returned... ");
		lStatus = pNtQuerySystemInformation(SystemProcessInformation, NULL, NULL, &ulProcesses);
		if (lStatus != 0xC0000004 /*STATUS_INFO_LENGTH_MISMATCH*/)
		{
			printNtStatus(L"pNtQuerySystemInformation", lStatus);
			break;
		}
		wprintf(L"done, size: %d\n", ulProcesses);

		wprintf(L"\t[i] Allocating buffer... ");
		systemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)ulProcesses);
		systemProcInfoOrig = systemProcInfo;
		if (systemProcInfo == NULL) {
			printError(L"HeapAlloc");
			break;
		}
		wprintf(L"done, address: 0x%p\n", systemProcInfo);

		wprintf(L"\t[i] Filling buffer with data... ");
		lStatus = pNtQuerySystemInformation(SystemProcessInformation, systemProcInfo, ulProcesses, NULL);
		if (lStatus != 0x0) {
			printNtStatus(L"pNtQuerySystemInformation", lStatus);
			break;
		}
		wprintf(L"done, size: %d\n", ulProcesses);

		do
		{
			if (dwOutSize >= *dwProcesses)
			{
				break;
			}

			if (systemProcInfo->ImageName.Length && wcscmp(systemProcInfo->ImageName.Buffer, szProcName) == 0)
			{
				pdwPid[dwOutSize] = (DWORD)systemProcInfo->UniqueProcessId;
				phProcess[dwOutSize] = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)systemProcInfo->UniqueProcessId);

				wprintf(L"\t[+] ProcessName: \"%s\" FOUND, PID: %d, hProcess: 0x%p\n", systemProcInfo->ImageName.Buffer, pdwPid[dwOutSize], phProcess[dwOutSize]);

				++dwOutSize;
			}

			if (systemProcInfo->NextEntryOffset == NULL)
			{
				break;
			}

			systemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)systemProcInfo + systemProcInfo->NextEntryOffset);

		} while (TRUE);

	} while (FALSE);

	if (systemProcInfoOrig != NULL)
	{
		HeapFree(GetProcessHeap(), 0, systemProcInfoOrig);
	}

	*dwProcesses = dwOutSize;

	if (dwOutSize == 0)
	{
		wprintf(L"[<] Looking for process: ERROR\n");
		return FALSE;
	}

	wprintf(L"[<] Looking for process: DONE\n");
	return TRUE;
}

