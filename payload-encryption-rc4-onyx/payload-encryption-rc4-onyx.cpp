#include <windows.h>
#include <stdio.h>
#include "misc.h"


/* RC4 implementation based on: https://www.oryx-embedded.com/doc/rc4_8c_source.html */

typedef struct
{
	unsigned int i;
	unsigned int j;
	unsigned char s[256];

} Rc4Context;

int rc4Init(Rc4Context* context, const unsigned char* key, size_t length)
{
	unsigned int i;
	unsigned int j;
	unsigned char temp;

	// Check parameters
	if (context == NULL || key == NULL)
		return ERROR_INVALID_PARAMETER;

	// Clear context
	context->i = 0;
	context->j = 0;

	// Initialize the S array with identity permutation
	for (i = 0; i < 256; i++)
	{
		context->s[i] = i;
	}

	// S is then processed for 256 iterations
	for (i = 0, j = 0; i < 256; i++)
	{
		//Randomize the permutations using the supplied key
		j = (j + context->s[i] + key[i % length]) % 256;

		//Swap the values of S[i] and S[j]
		temp = context->s[i];
		context->s[i] = context->s[j];
		context->s[j] = temp;
	}

}

void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length) {
	unsigned char temp;

	// Restore context
	unsigned int i = context->i;
	unsigned int j = context->j;
	unsigned char* s = context->s;

	// Encryption loop
	while (length > 0)
	{
		// Adjust indices
		i = (i + 1) % 256;
		j = (j + s[i]) % 256;

		// Swap the values of S[i] and S[j]
		temp = s[i];
		s[i] = s[j];
		s[j] = temp;

		// Valid input and output?
		if (input != NULL && output != NULL)
		{
			//XOR the input data with the RC4 stream
			*output = *input ^ s[(s[i] + s[j]) % 256];

			//Increment data pointers
			input++;
			output++;
		}

		// Remaining bytes to process
		length--;
	}

	// Save context
	context->i = i;
	context->j = j;
}

void rc4Onyx(PBYTE pDataIn, PBYTE pDataOut, SIZE_T sDataSize, PBYTE pKey, SIZE_T sKeySize)
{
	Rc4Context ctx = { 0 };

	rc4Init(&ctx, pKey, sKeySize);

	rc4Cipher(&ctx, pDataIn, pDataOut, sDataSize);
}

int main()
{
	// msfvenom -p windows/exec CMD=notepad.exe -f c
	BYTE bufEnc[] =
		"\x7f\x68\x30\x9c\x81\x39\x96\x98\x71\x52\xa7\xca\x22\x8b\xbf\x61"
		"\x48\x50\x78\x5e\xea\x2a\x7c\x23\xfc\xb3\x5b\x72\x42\x27\x88\x03"
		"\x3b\xa6\xf8\x2f\x35\x50\x8f\x07\xcd\xb2\xf4\xa8\xe1\xaf\x30\xf3"
		"\x1f\x4c\xb3\x97\x19\x06\xc5\x12\x89\x8b\x44\x86\x21\xb3\x86\x7b"
		"\x05\x88\xc8\x01\xf4\x0d\x55\x91\x78\x23\xf9\x66\x81\x51\x67\x4b"
		"\x7b\x79\x9d\xdc\xfb\xe0\xd6\x5e\x13\xe1\xa6\x6d\xa6\x83\x5f\x61"
		"\x76\x40\xd1\xee\xdc\xe8\xdf\x5c\x46\x77\x48\x8f\x91\x13\xfa\xf5"
		"\xd2\xe2\x3d\x98\x21\xaa\xf9\xb9\xcc\xad\xca\xeb\x82\xf2\xe6\x0e"
		"\xe6\x9f\xdc\xd3\xe3\x04\x68\xb0\xb0\x3d\x1d\xfc\x16\xd8\xab\xf1"
		"\xde\xa0\x69\x3b\x74\xd6\xf8\x10\xda\x22\x2c\x96\xe8\x68\x71\x7e"
		"\xeb\xbb\x5d\x50\x4f\x81\x9d\x06\x7f\xf3\x13\xc7\x85\x95\xc7\xeb"
		"\xa0\x89\x62\x14\x4e\xa1\x0a\x6d\x23\x54\x83\x2d\xbf\xe1\xeb\xac"
		"\x78\xc4\x00\x14";

	SIZE_T sBufEnc = (sizeof(bufEnc) / sizeof(BYTE)) - 1;

	BYTE bufOut[1024] = { 0 };

	BYTE key[] = "\xAB\xCD\xEF\xF0\x0F";
	SIZE_T sKey = (sizeof(key) / sizeof(BYTE)) - 1;

	printHex(bufEnc, sBufEnc);

	rc4Onyx(bufEnc, bufOut, sBufEnc, key, sKey);

	printHex(bufOut, sBufEnc);


	return 0;
}